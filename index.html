<!DOCTYPE html>
<html  lang="ja">
    <head>
        <meta charset="UTF-8">
        <title>テスト用画面</title>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
        <style>
            #output {
                position: fixed;
                top: 0px;
                right: 0px;
                border: 10px solid #000000;
            }
        </style>
    </head>
    <body>
        <h1>タッチレス操作実験画面</h1>
        <p>右上の窓に、緑の手が映れば操作可能です</p>

        <video id="input" hidden></video>
        <canvas id="output" width="160" height="120" style="border: 2px solid #000;"></canvas>

        <button id="start">start</button>
        <button id="stop">stop</button>
        <p>上下フリックでページスクロール</p>
        <p>ピースで動画再生、パーで動画停止。</p>
        <p>左右フリックで動画再生時間を10秒進める/戻す</p>
        <video id="target_video" src="./testvideo.mp4" controls></video>
        <p id="poit_data"></p>
        <div id="gesture"></div>
        <p>0<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99</p>
    </body> 
</html>
<script defer>
    const video = document.getElementById('input');
    const canvas = document.getElementById('output');
    const ctx = canvas.getContext('2d');
    const display_p = document.getElementById('poit_data');
    const gestureDiv = document.getElementById('gesture');  // ← 追加

    const flipCanvas = document.createElement('canvas');
    flipCanvas.width = 640; flipCanvas.height = 480;
    const flipCtx = flipCanvas.getContext('2d');

    let finalString = "";
    let hitosashi_y = 0.0;
    let hitosashi_nemoto_y = 0.0;
    let hitosashi_x = 0.0;
    let hitosashi_nemoto_x = 0.0;
    let y_flick_flag = 0;
    let y_flick_point = 0;
    let y_flick_start = 0;
    let y_flick_before = 0;
    let y_flick_cooldown = 0;
    let x_flick_flag = 0;
    let x_flick_point = 0;
    let x_flick_start = 0;
    let x_flick_before = 0;
    let x_flick_cooldown = 0;

    const config = { locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` };
    const hands = new Hands(config);

    const camera = new Camera(video, {
      onFrame: async () => {
        if (y_flick_cooldown != 0) {
          y_flick_cooldown += y_flick_cooldown > 0 ? -1 : 1;
        }
        if (x_flick_cooldown != 0) {
          x_flick_cooldown += x_flick_cooldown > 0 ? -1 : 1;
        }
        flipCtx.save();
        flipCtx.scale(-1, 1);
        flipCtx.drawImage(video, -flipCanvas.width, 0, flipCanvas.width, flipCanvas.height);
        flipCtx.restore();
        await hands.send({ image: flipCanvas });
      },
      facingMode: { exact: "user" },
      width: { ideal: 640 },
      height: { ideal: 480 },
    });

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 0,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });
    function isFingerUp(landmarks, tipIndex, pipIndex) {
      return landmarks[tipIndex].y < landmarks[pipIndex].y - 0.1;
    }
    function detectGesture(landmarks) {
      const wrist = landmarks[0];
      const tips = [4,8,12,16,20];
      const pips = [2,6,10,14,18];
      const up = tips.map((tip, i) => isFingerUp(landmarks, tip, pips[i]));
      if (up[1] && up[2] && up[3] && up[4]) return "パー";
      if (up[1] && !up[2] && !up[3] && up[4]) return "yeah!";
      if (up[1] && up[2] && up[3] && !up[4]) return "スリー";
      if (up[1] && up[2] && !up[3] && !up[4]) return "ピース";
      if (up[1] && !up[2] && !up[3] && !up[4]) return "人差し指";
      if (!up[1] && !up[2] && !up[3] && !up[4]) return "グー";
    }

    // ビデオ操作系
    const videoElement = document.getElementById('target_video');
    function targetPlay() {
      if (videoElement.paused) {
        videoElement.play();
      };
    };
    function targetStop() {
      if (videoElement.paused) {
      }else{
        videoElement.pause();
        
      };
    };
    function targetSkip() {
      let video_now = videoElement.currentTime+10.0;
      videoElement.currentTime=video_now;
    };
    function targetSkipReturn() {
      let video_now = videoElement.currentTime-10.0;
      if (video_now<0.0){video_now=0.0};
      videoElement.currentTime=video_now;
    };

    let lastGesture = "";
    let lastTime = 0;

    hands.onResults(results => {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      //ctx.drawImage(results.image,0,0,canvas.width,canvas.height);
      if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const marks = results.multiHandLandmarks[0];
        drawConnectors(ctx, marks, HAND_CONNECTIONS, {color: '#0f0'});
        //drawLandmarks(ctx, marks, {color: '#f00'});

        hitosashi_y = Math.round(marks[8].y*100)/100;
        hitosashi_nemoto_y = Math.round(marks[5].y*100)/100;
        hitosashi_x = Math.round(marks[8].x*100)/100;
        hitosashi_nemoto_x = Math.round(marks[5].x*100)/100;
        finalString = "上下フリッククールダウン" + (y_flick_cooldown>=1?"(上)":"") + (y_flick_cooldown<=-1?"(下)":"") + y_flick_cooldown + "<br>";
        if (y_flick_cooldown==0){
          if (y_flick_flag==0){
            if ((hitosashi_y<y_flick_before)&&(y_flick_before-hitosashi_y>=0.15)){
              y_flick_flag=1;
            }else if ((hitosashi_y>y_flick_before)&&(hitosashi_y-y_flick_before>=0.25)){
              y_flick_flag=-1;
            }
          }else if (y_flick_flag==1){
            if (hitosashi_y<y_flick_before){ y_flick_point+=1; }
            else { y_flick_flag=0; y_flick_point=0; }
            if ((y_flick_point>=3)&&(hitosashi_nemoto_y-hitosashi_y>=0.25)){
              y_flick_flag=0; y_flick_point=0; y_flick_cooldown=30;
              window.scrollBy({top: 200, behavior: 'smooth'});
            }
          }else if (y_flick_flag==-1){
            if (y_flick_before<hitosashi_y){ y_flick_point+=1; }
            else { y_flick_flag=0; y_flick_point=0; }
            if ((y_flick_point>=2)&&(hitosashi_y-hitosashi_nemoto_y>=0.1)){
              y_flick_flag=0; y_flick_point=0; y_flick_cooldown=-30;
              window.scrollBy({top: -200, behavior: 'smooth'});
            }
          }
        }
        y_flick_before = hitosashi_y;

        finalString += "左右フリッククールダウン" + (x_flick_cooldown>=1?"(右)":"") + (x_flick_cooldown<=-1?"(左)":"") + x_flick_cooldown + "<br>";
        if (x_flick_cooldown==0){
          if (x_flick_flag==0){
            if ((hitosashi_x>x_flick_before)&&(hitosashi_x-x_flick_before>=0.15)){
              x_flick_flag=1;
            }else if ((hitosashi_x<x_flick_before)&&(x_flick_before-hitosashi_x>=0.15)){
              x_flick_flag=-1;
            }
          }else if (x_flick_flag==1){
            if (hitosashi_x>x_flick_before){ x_flick_point+=1; }
            else { x_flick_flag=0; x_flick_point=0; }
            if ((x_flick_point>=3)&&(hitosashi_x-hitosashi_nemoto_x>=0.2)){
              x_flick_flag=0; x_flick_point=0; x_flick_cooldown=30;
              targetSkip();
            }
          }else if (x_flick_flag==-1){
            if (x_flick_before>hitosashi_x){ x_flick_point+=1; }
            else { x_flick_flag=0; x_flick_point=0; }
            if ((x_flick_point>=3)&&(hitosashi_nemoto_x-hitosashi_x>=0.2)){
              x_flick_flag=0; x_flick_point=0; x_flick_cooldown=-30;
              targetSkipReturn();
            }
          }
        }
        x_flick_before = hitosashi_x;

        finalString += `人差し指y=${hitosashi_y}<br>人差し指根本y=${hitosashi_nemoto_y}<br>人差し指x=${hitosashi_x}<br>人差し指根本x=${hitosashi_nemoto_x}<br>`;

        const currentGesture = detectGesture(marks);
        // ジェスチャーで動画操作
        if (currentGesture=="ピース"){
          targetPlay();
        }else if (currentGesture=="パー"){
          targetStop();
        };
        gestureDiv.textContent = currentGesture;
      }
      display_p.innerHTML = finalString;
    });

    document.getElementById('start').addEventListener('click', () => camera.start());
    document.getElementById('stop').addEventListener('click', () => camera.stop());
</script>
